# Episode 02 ‚Äì Low Level Design (LLD) & API Design

## Phase 1 ‚Äì Planning (Before Writing Code)

In **Phase 1**, no actual coding is done.

Focus is on:
- Technical planning
- System structure
- Deciding how different parts will communicate

At this stage:
- **No tech stack implementation**
- Only **design and architecture decisions**

---

## Microservices Overview (Project Level)

For **Gittogether**, we logically separate the system into two services:

1Ô∏è‚É£ **Frontend Service**
- Handles UI
- User interaction
- Client-side logic

2Ô∏è‚É£ **Backend Service**
- Handles APIs
- Business logic
- Database operations

> Even if deployed together initially, they are **conceptually separate services**.

---

## What is LLD (Low Level Design)?

**LLD = Low Level Design**

LLD focuses on:
- Database schema
- API contracts
- Models
- Data flow
- Request & response structure

üëâ The **most important part of LLD is API Design**.

---

## Database Design

In database design, we decide:
- What data to store
- How to structure data
- How relationships will work

Since **many users will join**, data must be:
- Scalable
- Well-structured
- Easy to query

---

## Database Choice ‚Äì MongoDB

Gittogether uses **MongoDB**.

### Why MongoDB?
- NoSQL (Document-based)
- Schema is flexible
- Easy to evolve with changing requirements
- Faster iteration during development

> Schema changes are **easier in MongoDB** compared to SQL databases.

---

## Core Collections (Database Schema)

### 1Ô∏è‚É£ User Collection

Stores user-related information.

**Fields:**
- `firstName`
- `lastName`
- `emailId`
- `password`
- `age`
- `gender`

Each user document represents **one registered user**.

---

### 2Ô∏è‚É£ ConnectionRequest Collection

Used when one user sends a connection request to another.

**Scenario:**
- User **A** sends a request to User **B**

**Fields:**
- `fromUserId` ‚Üí sender
- `toUserId` ‚Üí receiver
- `status` ‚Üí `pending | accepted | rejected`

This allows us to:
- Track relationships
- Manage connection states

---

## Importance of Defining Models First

üëâ **Models must be defined before writing business logic.**

Reasons:
- Clean architecture
- Less refactoring later
- Predictable data flow

### Industry Reality
- In large companies, **schema changes are expected to be minimal**
- SQL schema changes are very complex
- MongoDB is more flexible, but still requires **careful planning**

That‚Äôs why **LLD is extremely important**.

---

## API Design

### What is an API?
An **API (Application Programming Interface)** is a bridge that allows:
- Software applications
- Frontend and backend  
to communicate with each other.

---

## REST API

**REST = Representational State Transfer**

REST APIs:
- Follow HTTP rules
- Use standard HTTP methods
- Are stateless

### Common HTTP Methods
- `GET` ‚Üí Fetch data
- `POST` ‚Üí Create new data
- `PUT` ‚Üí Update entire resource
- `PATCH` ‚Üí Update partial resource
- `DELETE` ‚Üí Remove data

---

## Difference Between PUT and PATCH

| Aspect | PUT | PATCH |
|------|-----|-------|
| Update Type | Full update | Partial update |
| Missing Fields | Overwritten | Preserved |
| Usage | Replace resource | Modify specific fields |

### Example
If a user has:
```json
{
  "name": "Amit",
  "age": 25,
  "gender": "Male"
}
